# Debugging

Things will not always work and C is more difficult than PHP. So how do you
debug a problem? For example:

## Segfaults

I changed the function to print "hello" in uppercase, but made a programming mistake.

```c
/* for toupper() */
#include <ctype.h>

PHP_FUNCTION(hello) {
  char *name = NULL;
  char *hello = "hello";
  size_t name_len = 0;

  hello[0] = toupper(hello[0]);

  if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &name, &name_len) == FAILURE) {
      return;
  }

  php_printf("%s %s\n", hello, name);
  RETURN_TRUE;
}
```

Let's see what happens when we run it:

```
$ php -dextension=modules/hello.so -a
Interactive shell

php > hello('world');
Segmentation fault
```

Now what?

### Get a coredump

Enable coredumps and run the program again:

```
ulimit -c unlimited
```

```
$ php -dextension=modules/hello.so -r "hello('world');"
Segmentation fault (core dumped)
```

A file named ```core``` will be created.

### Find problem

Run the GNU debugger on php with your coredump.

```
$ gdb php core
...
Core was generated by `php -dextension=modules/hello.so -r hello('world');'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00007fe35992896e in zif_hello (execute_data=0x7fe35a6130a0, return_value=0x7fe35a613090) at .../manuscript/CoreDump/hello.c:42
42	  hello[0] = toupper(hello[0]);
```

It immediately points out that there is a problem with the ```toupper()``` in ```hello.c``` at line 42.
It will not always be this obvious, sometimes you want to get a backtrace to see how you got at this line. Run ```bt``` to get a full stack trace:

```
((gdb) bt
#0  0x00007fe35992896e in zif_hello (execute_data=0x7fe35a6130a0, return_value=0x7fe35a613090) at .../manuscript/CoreDump/hello.c:42
#1  0x0000000000b052d8 in ZEND_DO_ICALL_SPEC_HANDLER () at .../Zend/zend_vm_execute.h:586
#2  0x0000000000b04d04 in execute_ex (ex=0x7fe35a613030) at .../Zend/zend_vm_execute.h:414
#3  0x0000000000b04e15 in zend_execute (op_array=0x7fe35a682000, return_value=0x7ffc179a0af0) at .../Zend/zend_vm_execute.h:458
#4  0x0000000000a8ea37 in zend_eval_stringl (str=0x1b1a680 "hello('world');", str_len=15, retval_ptr=0x0, string_name=0x1138ae4 "Command line code")
    at .../Zend/zend_execute_API.c:1135
#5  0x0000000000a8ec5c in zend_eval_stringl_ex (str=0x1b1a680 "hello('world');", str_len=15, retval_ptr=0x0, string_name=0x1138ae4 "Command line code",
    handle_exceptions=1) at .../Zend/zend_execute_API.c:1176
#6  0x0000000000a8ece2 in zend_eval_string_ex (str=0x1b1a680 "hello('world');", retval_ptr=0x0, string_name=0x1138ae4 "Command line code", handle_exceptions=1)
    at .../Zend/zend_execute_API.c:1187
#7  0x0000000000b6df9d in do_cli (argc=4, argv=0x1b3dcb0) at .../sapi/cli/php_cli.c:1005
#8  0x0000000000b6f065 in main (argc=4, argv=0x1b3dcb0) at .../sapi/cli/php_cli.c:1344
```

You can also step debug it. Run the program again under gdb and set a breakpoint on line 38.

```
$ gdb --args php -dextension=modules/hello.so -r "hello('world');"
...
(gdb) break hello.c:38
No source file named hello.c.
Make breakpoint pending on future shared library load? (y or [n]) y
Breakpoint 1 (hello.c:38) pending.
```

Then actually run the program and step through it.

```
(gdb) run
Starting program: php -dextension=modules/hello.so -r hello\(\'world\'\)\;

Breakpoint 1, zif_hello (execute_data=0x7fffecc130a0, return_value=0x7fffecc13090) at .../manuscript/CoreDump/hello.c:38
38	  char *name = NULL;
(gdb) s
39	  char *hello = "hello";
(gdb) s
40	  size_t name_len = 0;
(gdb) s
42	  hello[0] = toupper(hello[0]);
(gdb) print hello
$1 = 0x7fffebf28a09 "hello"
(gdb) s
toupper (c=104) at ctype.c:52
52	  return c >= -128 && c < 256 ? __ctype_toupper[c] : c;
(gdb) s
53	}
(gdb) s

Program received signal SIGSEGV, Segmentation fault.
0x00007fffebf2896e in zif_hello (execute_data=0x7fffecc130a0, return_value=0x7fffecc13090) at .../manuscript/CoreDump/hello.c:42
42	  hello[0] = toupper(hello[0]);
```

The problem with the program is that the ```char *hello = "hello";``` should have been a ```char hello[] = "hello";```.
Rookie mistake, read "The C programming language" (K&R) section 5.5 "Character Pointers and Functions" for more information.

## Memory leaks

Let's make the function leak memory by allocating 128 bytes of memory and not releasing them:

```c
PHP_FUNCTION(hello) {
  char *name = NULL;
  size_t name_len = 0;

  emalloc(128);

  if (zend_parse_parameters(ZEND_NUM_ARGS(), "s", &name, &name_len) == FAILURE) {
      return;
  }

  php_printf("Hello %s\n", name);
  RETURN_TRUE;
}
```

Let's see what happens when we run it:

```
$ php -dextension=modules/hello.so -r "hello('world');"
Hello world
[Sun Jul 24 17:30:07 2016]  Script:  '-'
.../manuscript/CoreDump/hello.c(38) :  Freeing 0x7F25B10731E0 (128 bytes), script=-
=== Total 1 memory leaks detected ===
```

PHP has an ini flag ```report_memleaks``` which is on by default. You can turn it off and PHP will no longer print info about the leak:

```
$ php -dreport_memleaks=Off -dextension=modules/hello.so -r "hello('world');"
Hello world
```

Tools like Valgrind and Electric Fence can help you find memory leaks. Make sure to turn off Zend Memory Manager when you try to detect memory leaks.

### Valgrind
